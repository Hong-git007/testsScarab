#!/usr/bin/env python3
import os
import re
from pathlib import Path

# ================== 사용자 설정 ==================
# 1. 처리하고 싶은 벤치마크 이름들을 리스트로 나열합니다.
BENCH_NAMES = [
    "perlbench_17_r_ref0", "perlbench_17_r_ref1", "perlbench_17_r_ref2",
    "gcc_17_r_ref0", "gcc_17_r_ref1", "gcc_17_r_ref2", "gcc_17_r_ref3", "gcc_17_r_ref4",
    "mcf_17_r_ref0",
    "omnetpp_17_r_ref0",
    "xalancbmk_17_r_ref0",
    "x264_17_r_ref0", "x264_17_r_ref1", "x264_17_r_ref2",
    "deepsjeng_17_r_ref0",
    "leela_17_r_ref0",
    "exchange2_17_r_ref0",
    "xz_17_r_ref0", "xz_17_r_ref1", "xz_17_r_ref2",
    "bwaves_17_r_ref0", "bwaves_17_r_ref1", "bwaves_17_r_ref2", "bwaves_17_r_ref3",
    "cactuBSSN_17_r_ref0",
    "namd_17_r_ref0",
    "parest_17_r_ref0",
    "povray_17_r_ref0",
    "lbm_17_r_ref0",
    "wrf_17_r_ref0",
    "blender_17_r_ref0",
    "cam4_17_r_ref0",
    "imagick_17_r_ref0",
    "nab_17_r_ref0",
    "fotonik3d_17_r_ref0",
    "roms_17_r_ref0",
]

# ================== 공통 경로 설정 ==================
# 1. 원본 벤치마크 정보가 있는 경로
base_run_dir = Path("/home/hong/simulator/Benchmarking/tools/scarab/spec2017_run_dir_rate")
program_descriptor_file = base_run_dir / "program_descriptor.def"

# 2. 최종 결과물을 저장할 경로
output_base_dir = Path("/home/hong/simulator/Benchmarking/testsScarab/simpoint")
bench_paths_mk = output_base_dir / "bench_paths.mk"

# ================== bench_paths.mk 파일 초기화 ==================
os.makedirs(output_base_dir, exist_ok=True)
with open(bench_paths_mk, "w") as f:
    f.write("# Auto-generated by script\n\n")

# ================== 각 벤치마크에 대해 루프 실행 ==================
for BENCH_NAME in BENCH_NAMES:
    print(f"Processing benchmark: {BENCH_NAME}...")

    bench_family = BENCH_NAME.split('_ref')[0]
    bench_dir = base_run_dir / bench_family / "ref/run_dir"
    
    # 더미 파일 이름
    output_csv = output_base_dir / f"simpoints_{BENCH_NAME}.csv"
    output_csv_weight = output_base_dir / f"simpoints_{BENCH_NAME}_weight.csv"

    program_name = None
    program_args = None

    try:
        # program_descriptor.def 파일에서 프로그램 이름과 인자 추출
        with open(program_descriptor_file) as f:
            for line in f:
                if BENCH_NAME in line:
                    parts = line.strip().split('"')
                    program_name = parts[3].strip().split()[0].lstrip('./')
                    program_args = " ".join(parts[3].strip().split()[1:])
                    break
        
        if program_name is None:
            raise ValueError(f"Bench name {BENCH_NAME} not found in {program_descriptor_file}")

        # bench_paths.mk 파일에 내용 추가
        if program_args:
            # 입력 파일 및 디렉터리 경로를 절대 경로로 변환
            abs_args = []
            for arg in program_args.split():
                # --- [수정된 부분] ---
                # `-I` 옵션과 같은 디렉터리 경로를 처리합니다.
                if arg.startswith("-I"):
                    potential_path = bench_dir / arg[2:]
                    if potential_path.exists():
                        abs_args.append(f'-I{str(potential_path)}')
                    else:
                        abs_args.append(arg)
                # 일반적인 파일 경로를 처리합니다.
                else:
                    potential_path = bench_dir / arg
                    if potential_path.exists() and potential_path.is_file():
                        abs_args.append(str(potential_path))
                    else:
                        abs_args.append(arg)
                # --- [수정된 부분 끝] ---
            program_args_abs = " ".join(abs_args)
        else:
            program_args_abs = ""

        with open(bench_paths_mk, "a") as f:
            f.write(f'PROGRAM_{BENCH_NAME} ?= {program_name}\n')
            f.write(f'PROGRAM_ARGS_{BENCH_NAME} ?= {program_args_abs}\n')
            f.write(f'SIMPOINTS_FILE_{BENCH_NAME} ?= {output_csv.name}\n')
            f.write(f'SIMPOINTS_FILE_WEIGHT_{BENCH_NAME} ?= {output_csv_weight.name}\n')
            f.write(f'BINARY_DIR_{BENCH_NAME} ?= {bench_dir}\n\n')

        print(f"  -> Successfully extracted info for {BENCH_NAME}.")
        print(f"  -> bench_paths.mk updated.")

    except (ValueError, FileNotFoundError) as e:
        print(f"  -> ERROR processing {BENCH_NAME}: {e}")

print("\nAll specified benchmarks have been processed.")